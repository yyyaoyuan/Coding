# 题目描述

输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

# 解答

大概的思路（个人根据解答的理解）：
* 首先需要两个列表：path和res，path用于记录经过的节点，res用于记录满足条件的path：sum(path) == expectNumber。
* 接下来进入递归函数内部，如果当前节点不为空，首先将当前节点装进path中，然后是写出递归的终止条件以及递归的主体。
* 递归的终止条件：当前节点是个叶子节点并且path列表中所有节点值的和为指定的数（*这个比较容易理解），就将当前的path添加进res中。注意，因为path是在变化的，所以这里使用的是path[:]，关于path[:]，因为path中并没有可变类型，
仅仅是节点值，所以我认为这里是深度拷贝，此时res中添加的path不会因为path后续的变化而变化（这里还需要注意的是，如果path中包含可变类型，如嵌入了一个list A，此时res中添加的path会因为list A的变化而变化，这里没有那么复杂，所以完全不用担心这种情况出现）。
* 递归的主体：首先在左子树继续寻找，然后在右子树寻找，最后回溯到当前节点的父亲节点。此过程有点不好理解，一个不好理解的内容是在左子树寻找的时候，仍然用了expectNumber，这是因为path是从根结点一直在记录，并不是剔除了当天节点，从新开始记录；另一个不好理解的过程就是回溯了，
当左右子树都遍历完，需要回退到当前节点的父亲节点，所以这里用了path.pop()操作。
* 函数返回值是res。

另外，不太清楚如何按照字典序的顺序进行打印，评论区有人说是按照路径的长度进行打印，但是我不确定长度和字典序的关系，希望后续回顾的时候可以理解吧。具体代码如下：
```python
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def __init__(self):
        self.path = []
        self.res = []
    def FindPath(self, root, expectNumber):
        if root:
            self.path.append(root.val)
            if not root.left and not root.right and sum(self.Path) == expectNumber:
                self.res.append(self.path[:])
            self.FindPath(root.left, expectNumber)
            self.FindPath(root.right, expectNumber)
            self.path.pop()
        return self.res
```

# 感想

这道题自己没什么思路，并且看了一些答案后也是感觉不一定完全理解了，不过这里还是要先记录一下，希望后面在看到这种题的时候，会很快的做出来。此外，
自己因为这道题，耽误了很多时间，以后在遇到比较绕的问题时，还是需要控制好时间，不然一方面打击自己的自信心，一方面浪费自己目前仅剩的非常宝贵的时间。
加油，加油，加油，加油，加油！！！！！！！一定要搞定编程题！！！！！！希望自己回过头来看这些历程的时候，已经可以很轻松的解决各种编程题了，并且找到了很满意的工作，加油！！！！
